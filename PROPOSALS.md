# AudioRAG Enhancement Proposals

This document outlines strategic ideas for reducing onboarding friction and refactoring the pipeline for generic audio support.

## 1. Reducing Onboarding Friction

To get a new developer from `uv pip install` or `pip install` to "First Query" in under 2 minutes.

### 1.1 Interactive CLI Setup (`audiorag setup`) âœ… IMPLEMENTED
**Problem**: Manual `.env` configuration is tedious and error-prone.
**Solution**: A Textual-based TUI that:
1. Guides users through provider selection (STT, Embeddings, Vector Store, Generation)
2. Provides one-click signup links for each provider
3. Accepts API keys with secure input (masked)
4. Validates key format
5. Generates `.env` file automatically

**Usage**:
```bash
uv pip install audiorag  # or: pip install audiorag
audiorag setup  # Launches interactive TUI
```

**Features**:
- Provider comparison (speed, cost, quality)
- Local vector store (ChromaDB) as default - no API key needed
- Direct links to provider signup pages
- Visual feedback on configuration status

### 1.2 Local-First Defaults
**Problem**: Cloud dependency by default.
**Solution**:
- ChromaDB (local vector store) as default - works out of the box
- Clear documentation on which providers require API keys
- Progressive enhancement: add API keys as needed

### 1.3 Quickstart Example Generator
**Problem**: Users don't know how to write their first script.
**Solution**: After setup, generate a `quickstart.py` file customized to their provider choices:
```python
# Generated by audiorag setup
from audiorag import AudioRAGPipeline, AudioRAGConfig

async def main():
    config = AudioRAGConfig()  # Loads from .env
    pipeline = AudioRAGPipeline(config)
    
    # Index audio
    await pipeline.index("https://youtube.com/watch?v=...")
    
    # Query
    result = await pipeline.query("What are the main points?")
    print(result.answer)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```

---

## 2. Generic Audio Support Refactor

Currently, `AudioRAGPipeline` is YouTube-centric. We need to elevate `LocalSource` and `URLSource` to first-class citizens.

### 2.1 Source Dispatcher (The "Auto-Source" Resolver)
**Problem**: The user has to manually choose `YouTubeSource` or `LocalSource`.
**Solution**: Implement a `SourceResolver` that automatically detects the source type.

```python
# Desired API
await pipeline.index("https://youtube.com/watch?v=...") # Detects YouTube
await pipeline.index("./recording.mp3")               # Detects Local
await pipeline.index("https://site.com/podcast.mp3")    # Detects URL
```

### 2.2 Unified Metadata Model
Ensure all sources return a standardized `AudioFile` object.
- **LocalSource**: Extract metadata from ID3 tags/FFmpeg info.
- **YouTubeSource**: Existing logic for titles and durations.
- **URLSource**: Extract from headers/URL path.

### 2.3 Directory Indexing
Add `pipeline.index_directory(path: Path)` to recursively discover and index all audio files in a folder, leveraging the `SourceResolver`.

### 2.4 Stream-Based Processing
Refactor the pipeline to support streaming bytes directly, allowing indexing of in-memory audio buffers or real-time streams without intermediate disk writes where possible.
